# Borg —— Google的大规模集群管理系统

## *Borg* 简介
* *Google* 的 *Borg* 系统是一个运行着成千上万项作业的集群管理器，它同时管理着很多个应用集群，每个集群都有成千上万台机器，这些集群之上运行着Google的很多不同的应用。

## *Borg* 主要特性
1. 超高的资源利用率：
    * 准入控制
    * 高效的任务打包
    * 超额的资源分配
    * 进程级隔离的机器共享

2. 支持高可用的应用程序
    * 运行时特性：最小化故障恢复时间
    * 调度策略：减少相关运行时故障

3. 简化用户使用
    * 作业声明的标准语言
    * 命名服务的集成机制
    * 实时的作业监控
    * 分析和模拟系统行为的工具

## *Borg* 如何运作

### 用户视图
* Borg的用户是运行Google应用和服务的Google开发人员和系统管理员（网站可靠性工程师或SRE）。 用户以作业的形式将他们的工作提交给Borg，每个作业包括一个或多个任务，它们都运行相同的程序（二进制）。 每个作业在一个Borg单元中运行，一组机器组织为一个单元。

* 工作负载
    * *“永远运行下去”的长服务* ： 对延迟和性能波动敏感， 此类服务用于面向终端用户的产品，例如Gmail，Google文档，web搜索和内部基础设施服务。
    * *批处理作业* ： 需要花费从几秒到几天完成，这些任务对短期性能波动的敏感性要小得多。这些工作负载混合运行在Borg的各个运行单元中，其根据其主要租户（例如，一些单元是专门用来运行批量密集任务的）运行不同的混合应用，并且也随时间变化。
* 集群 *cluster*、单元 *cell*
    * 单元中的机器属于单个集群，由连接它们的高性能数据中心规模的网络架构定义。一个集群通常承载一个大型单元，可能有一些较小规模的测试或特殊用途单元。
    * Borg通过确定单元中的运行任务，为任务分配资源，安装程序和其他的依赖，监控任务状态并在失败时重启，将用户从大多数差异中隔离出来。
* 作业、任务
    * 作业 *job* 
        * 属性包括名称，所有者及其拥有的任务数量。
        * 作业可能具有限制，使其任务在具有特定属性的计算机上运行。
        * 作业的开始能被推迟到直到前一个作业完成。 一个作业仅在一个单元中运行。
    * 任务 *task*
        * 每个任务映射到在机器上的容器中运行的一组Linux进程。
        * 大多数任务属性对作业中的所有任务是相同的，但是可以被重写；每个资源维度（CPU核，RAM，磁盘空间，磁盘访问速率，TCP端口，等）以细粒度独立指定。
        * 静态链接Borg程序以减少对其运行时环境的依赖，并且Brog程序被打包为二进制文件和数据文件，由Borg负责安装。

    * 用户通过向Borg发出远程过程调用（RPC）来操作作业，可以通过推送新的作业配置到Borg，再指示Borg将任务更新到新配置，来更改正在运行的作业中的某些任务或所有任务的属性。这是一个轻量级的非原子事务，可以很容易地被撤销，直到它被关闭（提交）。
* 分配 *Borg Alloc*
    * 可以运行一个或多个任务的机器上的一组保留资源，无论资源是否被使用仍然被分配。
    * 为将来的任务设置资源，在停止和重启任务之间保留资源，以及将不同作业中的任务收集到同一台机器上。
* 优先级，配额和接纳控制
    * 每个作业都有一个优先级。高优先级任务可以以牺牲低优先级任务为代价获得资源。
    * 配额用于决定允许进行调度的作业，表示在给定优先级上的一段时间（通常为几个月）内的资源量（CPU，RAM，磁盘等）。
* 命名、监控
    * Borg将为每个任务创建一个稳定的 *Borg name service*（BNS）名称，其中包含单元名称，作业名称和任务编号。Borg将任务的主机名和端口写入一个以 BNS 命名的一致的高可用的 *Chubby* 文件中，由我们的 RPC 系统使用该文件来查找任务端点。
    * 几乎在Borg下运行的每个任务都包含一个内置的HTTP服务器，它发布有关任务运行状况的信息和成千上万个性能指标。Borg监控health-check URL，并重新启动不会及时响应或返回HTTP错误代码的任务。
### 体系结构
* Borgmaster

    * 每个单元的Borgmaster包括两个进程：主进程Borgmaster和独立的调度程序。
    * 主Borgmaster进程处理客户端RPC，状态变化（例如，创建作业）或提供对数据的只读访问（例如，查找作业）。它还管理系统中所有对象（机器，任务，分配等）的状态机，与Borglets进行通信，并提供Web UI作为Sigma的备份。
* 调度
    * 提交作业时，Borgmaster会将其持久化在Paxos存储中，并将作业的任务添加到等待队列。
    * 调度程序异步扫描，如果有足够的可用资源满足作业的要求，则会将任务分配给机器。
    * 扩展：
        * 评估分数缓存
        * 等价类
        * 轻松随机化
* Borglet
    * 本地Borg代理，存在于单元中的每一台机器中。
    * 启动和停止任务；如果故障就重启任务；通过操纵操作系统内核设置来管理本地资源；翻转调试日志；向Borgmaster等监控系统报告机器的状态。

### 性能策略
* 可用性
    * 如有必要，在新机器上自动重新安排逐出的任务
    * 通过在诸如机器，机架和电源域之类的故障域中扩展作业的任务，减少相关故障
    * 限制任务中断的允许速率和任务数量，这些任务可以在维护活动（例如操作系统或机器更新）期间同时关闭
    * 使用声明性期望状态表示和幂等变换操作，使得失败的客户端可以无损地重新提交任何被遗忘的请求
    * rate-limits找到无法访问的机器的任务的新位置，因为它无法区分大型机器故障和网络分区
    * 避免重复任务导致任务或机器崩溃的机器配对。
    * 通过不断重新运行日志记录器任务来恢复写入本地磁盘的关键中间数据。
    * …………
    
* 机器利用
    * *cell共享* ： 回收利用proc作业预留用来处理稀有的负载高峰的资源来运行大部分non-proc工作
    **会导致 CPU干扰而降低 CPU性能，但面对所有资源总体表现更优*
    * *大单元* ： 允许运行大型计算，并减少资源碎片。
    * *细粒度资源请求*
    * *资源回收* ： 估计任务将使用多少资源，并回收可以容忍低质量资源（例如批处理作业）的工作的剩余资源，并且由Borgmaster每几秒钟使用由Borglet捕获的细粒度使用（资源消耗）信息来计算。

* 隔离
    * 安全隔离： Linux chroot jail
    * 性能隔离： 所有Borg任务都在基于Linux cgroup的资源容器中运行，Borglet操作容器设置，提供更好的控制

## *Borg* 的优劣
* 优点
    * Borg alloc抽象概念产生了广泛使用的日志存储模式。
    * 集群管理不仅仅是任务管理。运行在Borg上的应用程序可以从许多其他集群服务中受益，包括命名和负载平衡。
    * 为了处理大量数据，提供了多个级别的UI和调试工具，因此用户可以快速识别与其作业相关的异常事件，然后从其应用程序和基础架构本身深入查看详细的事件和错误日志。
    * 主机是分布式系统的内核。这使得 *Borg* 能够在不牺牲性能或可维护性的情况下扩展工作负载和功能集。

* 不足
    * 作为任务的唯一分组机制，作业是限制性的。
    * 每个机器一个IP地址使事情复杂化。
    * 针对高级用户进行优化，牺牲了休闲用户。